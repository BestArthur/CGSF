// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SFPacketStore.proto

#ifndef PROTOBUF_SFPacketStore_2eproto__INCLUDED
#define PROTOBUF_SFPacketStore_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace SFPacketStore {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SFPacketStore_2eproto();
void protobuf_AssignDesc_SFPacketStore_2eproto();
void protobuf_ShutdownFile_SFPacketStore_2eproto();

class Login;
class LoginSuccess;
class LoginFail;
class TeamInfo;
class TeamInfo_TeamMember;
class EnterTeamMember;
class LeaveTeamMember;
class InvalidPacket;
class EnterLobby;
class ChatReq;
class ChatRes;
class EnterRoom;
class CreateRoom;
class LeaveRoom;
class RoomList;
class RoomList_RoomInfo;
class ChangeTeam;
class StartGame;
class LoadingComplete;
class PlayStart;
class PlayMove;
class PlayEnd;
class PlayScoreInfo;
class PlayPlayerScore;
class PeerList;
class PeerList_PeerInfo;
class MSG_CREATE_PLAYER;
class MSG_DESTROY_PLAYER;
class MSG_PLAYER_MOVE_UPDATE;
class MSG_PLAYER_LOOK_UPDATE;
class MSG_PLAYER_HEALTH;
class MSG_PLAYER_SCORE;
class MSG_PLAYER_WEAPON_CHANGE;
class MSG_PLAYER_WEAPON_CHANGING;
class MSG_SPAWN_PLAYER;
class PLAYER_IP;
class ADD_PEER;
class DELETE_PEER;

enum TeamType {
  NONE = -1,
  RED = 0,
  BLUE = 1
};
bool TeamType_IsValid(int value);
const TeamType TeamType_MIN = NONE;
const TeamType TeamType_MAX = BLUE;
const int TeamType_ARRAYSIZE = TeamType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TeamType_descriptor();
inline const ::std::string& TeamType_Name(TeamType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TeamType_descriptor(), value);
}
inline bool TeamType_Parse(
    const ::std::string& name, TeamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TeamType>(
    TeamType_descriptor(), name, value);
}
// ===================================================================

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();
  
  Login(const Login& from);
  
  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();
  
  void Swap(Login* other);
  
  // implements Message ----------------------------------------------
  
  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string UserName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string Password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.Login)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class LoginSuccess : public ::google::protobuf::Message {
 public:
  LoginSuccess();
  virtual ~LoginSuccess();
  
  LoginSuccess(const LoginSuccess& from);
  
  inline LoginSuccess& operator=(const LoginSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginSuccess& default_instance();
  
  void Swap(LoginSuccess* other);
  
  // implements Message ----------------------------------------------
  
  LoginSuccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginSuccess& from);
  void MergeFrom(const LoginSuccess& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // required bytes UserInfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 2;
  inline const ::std::string& userinfo() const;
  inline void set_userinfo(const ::std::string& value);
  inline void set_userinfo(const char* value);
  inline void set_userinfo(const void* value, size_t size);
  inline ::std::string* mutable_userinfo();
  inline ::std::string* release_userinfo();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.LoginSuccess)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* userinfo_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static LoginSuccess* default_instance_;
};
// -------------------------------------------------------------------

class LoginFail : public ::google::protobuf::Message {
 public:
  LoginFail();
  virtual ~LoginFail();
  
  LoginFail(const LoginFail& from);
  
  inline LoginFail& operator=(const LoginFail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginFail& default_instance();
  
  void Swap(LoginFail* other);
  
  // implements Message ----------------------------------------------
  
  LoginFail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginFail& from);
  void MergeFrom(const LoginFail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.LoginFail)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static LoginFail* default_instance_;
};
// -------------------------------------------------------------------

class TeamInfo_TeamMember : public ::google::protobuf::Message {
 public:
  TeamInfo_TeamMember();
  virtual ~TeamInfo_TeamMember();
  
  TeamInfo_TeamMember(const TeamInfo_TeamMember& from);
  
  inline TeamInfo_TeamMember& operator=(const TeamInfo_TeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamInfo_TeamMember& default_instance();
  
  void Swap(TeamInfo_TeamMember* other);
  
  // implements Message ----------------------------------------------
  
  TeamInfo_TeamMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamInfo_TeamMember& from);
  void MergeFrom(const TeamInfo_TeamMember& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline const ::std::string& member() const;
  inline void set_member(const ::std::string& value);
  inline void set_member(const char* value);
  inline void set_member(const char* value, size_t size);
  inline ::std::string* mutable_member();
  inline ::std::string* release_member();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.TeamInfo.TeamMember)
 private:
  inline void set_has_member();
  inline void clear_has_member();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* member_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static TeamInfo_TeamMember* default_instance_;
};
// -------------------------------------------------------------------

class TeamInfo : public ::google::protobuf::Message {
 public:
  TeamInfo();
  virtual ~TeamInfo();
  
  TeamInfo(const TeamInfo& from);
  
  inline TeamInfo& operator=(const TeamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamInfo& default_instance();
  
  void Swap(TeamInfo* other);
  
  // implements Message ----------------------------------------------
  
  TeamInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamInfo& from);
  void MergeFrom(const TeamInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TeamInfo_TeamMember TeamMember;
  
  // accessors -------------------------------------------------------
  
  // required .SFPacketStore.TeamType Type = 1 [default = RED];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline SFPacketStore::TeamType type() const;
  inline void set_type(SFPacketStore::TeamType value);
  
  // repeated .SFPacketStore.TeamInfo.TeamMember Member = 6;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 6;
  inline const ::SFPacketStore::TeamInfo_TeamMember& member(int index) const;
  inline ::SFPacketStore::TeamInfo_TeamMember* mutable_member(int index);
  inline ::SFPacketStore::TeamInfo_TeamMember* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >*
      mutable_member();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.TeamInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember > member_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static TeamInfo* default_instance_;
};
// -------------------------------------------------------------------

class EnterTeamMember : public ::google::protobuf::Message {
 public:
  EnterTeamMember();
  virtual ~EnterTeamMember();
  
  EnterTeamMember(const EnterTeamMember& from);
  
  inline EnterTeamMember& operator=(const EnterTeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterTeamMember& default_instance();
  
  void Swap(EnterTeamMember* other);
  
  // implements Message ----------------------------------------------
  
  EnterTeamMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterTeamMember& from);
  void MergeFrom(const EnterTeamMember& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline const ::std::string& member() const;
  inline void set_member(const ::std::string& value);
  inline void set_member(const char* value);
  inline void set_member(const char* value, size_t size);
  inline ::std::string* mutable_member();
  inline ::std::string* release_member();
  
  // required .SFPacketStore.TeamType Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline SFPacketStore::TeamType type() const;
  inline void set_type(SFPacketStore::TeamType value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterTeamMember)
 private:
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* member_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static EnterTeamMember* default_instance_;
};
// -------------------------------------------------------------------

class LeaveTeamMember : public ::google::protobuf::Message {
 public:
  LeaveTeamMember();
  virtual ~LeaveTeamMember();
  
  LeaveTeamMember(const LeaveTeamMember& from);
  
  inline LeaveTeamMember& operator=(const LeaveTeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveTeamMember& default_instance();
  
  void Swap(LeaveTeamMember* other);
  
  // implements Message ----------------------------------------------
  
  LeaveTeamMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveTeamMember& from);
  void MergeFrom(const LeaveTeamMember& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline const ::std::string& member() const;
  inline void set_member(const ::std::string& value);
  inline void set_member(const char* value);
  inline void set_member(const char* value, size_t size);
  inline ::std::string* mutable_member();
  inline ::std::string* release_member();
  
  // required .SFPacketStore.TeamType Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline SFPacketStore::TeamType type() const;
  inline void set_type(SFPacketStore::TeamType value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.LeaveTeamMember)
 private:
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* member_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static LeaveTeamMember* default_instance_;
};
// -------------------------------------------------------------------

class InvalidPacket : public ::google::protobuf::Message {
 public:
  InvalidPacket();
  virtual ~InvalidPacket();
  
  InvalidPacket(const InvalidPacket& from);
  
  inline InvalidPacket& operator=(const InvalidPacket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvalidPacket& default_instance();
  
  void Swap(InvalidPacket* other);
  
  // implements Message ----------------------------------------------
  
  InvalidPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvalidPacket& from);
  void MergeFrom(const InvalidPacket& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Arg = 1;
  inline bool has_arg() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 1;
  inline const ::std::string& arg() const;
  inline void set_arg(const ::std::string& value);
  inline void set_arg(const char* value);
  inline void set_arg(const char* value, size_t size);
  inline ::std::string* mutable_arg();
  inline ::std::string* release_arg();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.InvalidPacket)
 private:
  inline void set_has_arg();
  inline void clear_has_arg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* arg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static InvalidPacket* default_instance_;
};
// -------------------------------------------------------------------

class EnterLobby : public ::google::protobuf::Message {
 public:
  EnterLobby();
  virtual ~EnterLobby();
  
  EnterLobby(const EnterLobby& from);
  
  inline EnterLobby& operator=(const EnterLobby& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterLobby& default_instance();
  
  void Swap(EnterLobby* other);
  
  // implements Message ----------------------------------------------
  
  EnterLobby* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterLobby& from);
  void MergeFrom(const EnterLobby& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 LobbyIndex = 1 [default = 0];
  inline bool has_lobbyindex() const;
  inline void clear_lobbyindex();
  static const int kLobbyIndexFieldNumber = 1;
  inline ::google::protobuf::int32 lobbyindex() const;
  inline void set_lobbyindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterLobby)
 private:
  inline void set_has_lobbyindex();
  inline void clear_has_lobbyindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 lobbyindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static EnterLobby* default_instance_;
};
// -------------------------------------------------------------------

class ChatReq : public ::google::protobuf::Message {
 public:
  ChatReq();
  virtual ~ChatReq();
  
  ChatReq(const ChatReq& from);
  
  inline ChatReq& operator=(const ChatReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReq& default_instance();
  
  void Swap(ChatReq* other);
  
  // implements Message ----------------------------------------------
  
  ChatReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatReq& from);
  void MergeFrom(const ChatReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Message = 1 [default = "\270\336\274\274\301\366\270\246 \263\326\300\270\274\274\277\344"];
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.ChatReq)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  static const ::std::string _default_message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static ChatReq* default_instance_;
};
// -------------------------------------------------------------------

class ChatRes : public ::google::protobuf::Message {
 public:
  ChatRes();
  virtual ~ChatRes();
  
  ChatRes(const ChatRes& from);
  
  inline ChatRes& operator=(const ChatRes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRes& default_instance();
  
  void Swap(ChatRes* other);
  
  // implements Message ----------------------------------------------
  
  ChatRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatRes& from);
  void MergeFrom(const ChatRes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string Sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  
  // required string Message = 2 [default = "\270\336\274\274\301\366\270\246 \263\326\300\270\274\274\277\344"];
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.ChatRes)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sender_;
  ::std::string* message_;
  static const ::std::string _default_message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static ChatRes* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoom : public ::google::protobuf::Message {
 public:
  EnterRoom();
  virtual ~EnterRoom();
  
  EnterRoom(const EnterRoom& from);
  
  inline EnterRoom& operator=(const EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoom& default_instance();
  
  void Swap(EnterRoom* other);
  
  // implements Message ----------------------------------------------
  
  EnterRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoom& from);
  void MergeFrom(const EnterRoom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 RoomIndex = 1;
  inline bool has_roomindex() const;
  inline void clear_roomindex();
  static const int kRoomIndexFieldNumber = 1;
  inline ::google::protobuf::int32 roomindex() const;
  inline void set_roomindex(::google::protobuf::int32 value);
  
  // required int32 GameMode = 2;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);
  
  // optional string Password = 3 [default = "None"];
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterRoom)
 private:
  inline void set_has_roomindex();
  inline void clear_has_roomindex();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 roomindex_;
  ::google::protobuf::int32 gamemode_;
  ::std::string* password_;
  static const ::std::string _default_password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static EnterRoom* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoom : public ::google::protobuf::Message {
 public:
  CreateRoom();
  virtual ~CreateRoom();
  
  CreateRoom(const CreateRoom& from);
  
  inline CreateRoom& operator=(const CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoom& default_instance();
  
  void Swap(CreateRoom* other);
  
  // implements Message ----------------------------------------------
  
  CreateRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoom& from);
  void MergeFrom(const CreateRoom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 GameMode = 1;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 1;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);
  
  // optional string Password = 2 [default = "None"];
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.CreateRoom)
 private:
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* password_;
  static const ::std::string _default_password_;
  ::google::protobuf::int32 gamemode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static CreateRoom* default_instance_;
};
// -------------------------------------------------------------------

class LeaveRoom : public ::google::protobuf::Message {
 public:
  LeaveRoom();
  virtual ~LeaveRoom();
  
  LeaveRoom(const LeaveRoom& from);
  
  inline LeaveRoom& operator=(const LeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveRoom& default_instance();
  
  void Swap(LeaveRoom* other);
  
  // implements Message ----------------------------------------------
  
  LeaveRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveRoom& from);
  void MergeFrom(const LeaveRoom& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 Reason = 1 [default = 0];
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.LeaveRoom)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 reason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static LeaveRoom* default_instance_;
};
// -------------------------------------------------------------------

class RoomList_RoomInfo : public ::google::protobuf::Message {
 public:
  RoomList_RoomInfo();
  virtual ~RoomList_RoomInfo();
  
  RoomList_RoomInfo(const RoomList_RoomInfo& from);
  
  inline RoomList_RoomInfo& operator=(const RoomList_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomList_RoomInfo& default_instance();
  
  void Swap(RoomList_RoomInfo* other);
  
  // implements Message ----------------------------------------------
  
  RoomList_RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomList_RoomInfo& from);
  void MergeFrom(const RoomList_RoomInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string RoomName = 1;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 1;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  
  // required string RoomChief = 2;
  inline bool has_roomchief() const;
  inline void clear_roomchief();
  static const int kRoomChiefFieldNumber = 2;
  inline const ::std::string& roomchief() const;
  inline void set_roomchief(const ::std::string& value);
  inline void set_roomchief(const char* value);
  inline void set_roomchief(const char* value, size_t size);
  inline ::std::string* mutable_roomchief();
  inline ::std::string* release_roomchief();
  
  // required int32 UserCount = 3;
  inline bool has_usercount() const;
  inline void clear_usercount();
  static const int kUserCountFieldNumber = 3;
  inline ::google::protobuf::int32 usercount() const;
  inline void set_usercount(::google::protobuf::int32 value);
  
  // required int32 MaxUserCount = 4;
  inline bool has_maxusercount() const;
  inline void clear_maxusercount();
  static const int kMaxUserCountFieldNumber = 4;
  inline ::google::protobuf::int32 maxusercount() const;
  inline void set_maxusercount(::google::protobuf::int32 value);
  
  // required int32 NeedPassword = 5;
  inline bool has_needpassword() const;
  inline void clear_needpassword();
  static const int kNeedPasswordFieldNumber = 5;
  inline ::google::protobuf::int32 needpassword() const;
  inline void set_needpassword(::google::protobuf::int32 value);
  
  // required int32 GameMode = 6;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 6;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomList.RoomInfo)
 private:
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_roomchief();
  inline void clear_has_roomchief();
  inline void set_has_usercount();
  inline void clear_has_usercount();
  inline void set_has_maxusercount();
  inline void clear_has_maxusercount();
  inline void set_has_needpassword();
  inline void clear_has_needpassword();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roomname_;
  ::std::string* roomchief_;
  ::google::protobuf::int32 usercount_;
  ::google::protobuf::int32 maxusercount_;
  ::google::protobuf::int32 needpassword_;
  ::google::protobuf::int32 gamemode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static RoomList_RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomList : public ::google::protobuf::Message {
 public:
  RoomList();
  virtual ~RoomList();
  
  RoomList(const RoomList& from);
  
  inline RoomList& operator=(const RoomList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomList& default_instance();
  
  void Swap(RoomList* other);
  
  // implements Message ----------------------------------------------
  
  RoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomList& from);
  void MergeFrom(const RoomList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef RoomList_RoomInfo RoomInfo;
  
  // accessors -------------------------------------------------------
  
  // repeated .SFPacketStore.RoomList.RoomInfo Info = 10;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 10;
  inline const ::SFPacketStore::RoomList_RoomInfo& info(int index) const;
  inline ::SFPacketStore::RoomList_RoomInfo* mutable_info(int index);
  inline ::SFPacketStore::RoomList_RoomInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >*
      mutable_info();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo > info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static RoomList* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTeam : public ::google::protobuf::Message {
 public:
  ChangeTeam();
  virtual ~ChangeTeam();
  
  ChangeTeam(const ChangeTeam& from);
  
  inline ChangeTeam& operator=(const ChangeTeam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeTeam& default_instance();
  
  void Swap(ChangeTeam* other);
  
  // implements Message ----------------------------------------------
  
  ChangeTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeTeam& from);
  void MergeFrom(const ChangeTeam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.ChangeTeam)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static ChangeTeam* default_instance_;
};
// -------------------------------------------------------------------

class StartGame : public ::google::protobuf::Message {
 public:
  StartGame();
  virtual ~StartGame();
  
  StartGame(const StartGame& from);
  
  inline StartGame& operator=(const StartGame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartGame& default_instance();
  
  void Swap(StartGame* other);
  
  // implements Message ----------------------------------------------
  
  StartGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartGame& from);
  void MergeFrom(const StartGame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.StartGame)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static StartGame* default_instance_;
};
// -------------------------------------------------------------------

class LoadingComplete : public ::google::protobuf::Message {
 public:
  LoadingComplete();
  virtual ~LoadingComplete();
  
  LoadingComplete(const LoadingComplete& from);
  
  inline LoadingComplete& operator=(const LoadingComplete& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadingComplete& default_instance();
  
  void Swap(LoadingComplete* other);
  
  // implements Message ----------------------------------------------
  
  LoadingComplete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadingComplete& from);
  void MergeFrom(const LoadingComplete& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.LoadingComplete)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static LoadingComplete* default_instance_;
};
// -------------------------------------------------------------------

class PlayStart : public ::google::protobuf::Message {
 public:
  PlayStart();
  virtual ~PlayStart();
  
  PlayStart(const PlayStart& from);
  
  inline PlayStart& operator=(const PlayStart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayStart& default_instance();
  
  void Swap(PlayStart* other);
  
  // implements Message ----------------------------------------------
  
  PlayStart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayStart& from);
  void MergeFrom(const PlayStart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayStart)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static PlayStart* default_instance_;
};
// -------------------------------------------------------------------

class PlayMove : public ::google::protobuf::Message {
 public:
  PlayMove();
  virtual ~PlayMove();
  
  PlayMove(const PlayMove& from);
  
  inline PlayMove& operator=(const PlayMove& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayMove& default_instance();
  
  void Swap(PlayMove* other);
  
  // implements Message ----------------------------------------------
  
  PlayMove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayMove& from);
  void MergeFrom(const PlayMove& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float PosX = 1;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosXFieldNumber = 1;
  inline float posx() const;
  inline void set_posx(float value);
  
  // required float PosY = 2;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosYFieldNumber = 2;
  inline float posy() const;
  inline void set_posy(float value);
  
  // required float PosZ = 3;
  inline bool has_posz() const;
  inline void clear_posz();
  static const int kPosZFieldNumber = 3;
  inline float posz() const;
  inline void set_posz(float value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayMove)
 private:
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_posz();
  inline void clear_has_posz();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float posx_;
  float posy_;
  float posz_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static PlayMove* default_instance_;
};
// -------------------------------------------------------------------

class PlayEnd : public ::google::protobuf::Message {
 public:
  PlayEnd();
  virtual ~PlayEnd();
  
  PlayEnd(const PlayEnd& from);
  
  inline PlayEnd& operator=(const PlayEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayEnd& default_instance();
  
  void Swap(PlayEnd* other);
  
  // implements Message ----------------------------------------------
  
  PlayEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayEnd& from);
  void MergeFrom(const PlayEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayEnd)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static PlayEnd* default_instance_;
};
// -------------------------------------------------------------------

class PlayScoreInfo : public ::google::protobuf::Message {
 public:
  PlayScoreInfo();
  virtual ~PlayScoreInfo();
  
  PlayScoreInfo(const PlayScoreInfo& from);
  
  inline PlayScoreInfo& operator=(const PlayScoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayScoreInfo& default_instance();
  
  void Swap(PlayScoreInfo* other);
  
  // implements Message ----------------------------------------------
  
  PlayScoreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayScoreInfo& from);
  void MergeFrom(const PlayScoreInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 RedKillCount = 1;
  inline bool has_redkillcount() const;
  inline void clear_redkillcount();
  static const int kRedKillCountFieldNumber = 1;
  inline ::google::protobuf::int32 redkillcount() const;
  inline void set_redkillcount(::google::protobuf::int32 value);
  
  // required int32 BlueKillCount = 2;
  inline bool has_bluekillcount() const;
  inline void clear_bluekillcount();
  static const int kBlueKillCountFieldNumber = 2;
  inline ::google::protobuf::int32 bluekillcount() const;
  inline void set_bluekillcount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayScoreInfo)
 private:
  inline void set_has_redkillcount();
  inline void clear_has_redkillcount();
  inline void set_has_bluekillcount();
  inline void clear_has_bluekillcount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 redkillcount_;
  ::google::protobuf::int32 bluekillcount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static PlayScoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayPlayerScore : public ::google::protobuf::Message {
 public:
  PlayPlayerScore();
  virtual ~PlayPlayerScore();
  
  PlayPlayerScore(const PlayPlayerScore& from);
  
  inline PlayPlayerScore& operator=(const PlayPlayerScore& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayPlayerScore& default_instance();
  
  void Swap(PlayPlayerScore* other);
  
  // implements Message ----------------------------------------------
  
  PlayPlayerScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayPlayerScore& from);
  void MergeFrom(const PlayPlayerScore& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 teamtype = 2;
  inline bool has_teamtype() const;
  inline void clear_teamtype();
  static const int kTeamtypeFieldNumber = 2;
  inline ::google::protobuf::int32 teamtype() const;
  inline void set_teamtype(::google::protobuf::int32 value);
  
  // required int32 kill = 3;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 3;
  inline ::google::protobuf::int32 kill() const;
  inline void set_kill(::google::protobuf::int32 value);
  
  // required int32 death = 4;
  inline bool has_death() const;
  inline void clear_death();
  static const int kDeathFieldNumber = 4;
  inline ::google::protobuf::int32 death() const;
  inline void set_death(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayPlayerScore)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_teamtype();
  inline void clear_has_teamtype();
  inline void set_has_kill();
  inline void clear_has_kill();
  inline void set_has_death();
  inline void clear_has_death();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 teamtype_;
  ::google::protobuf::int32 kill_;
  ::google::protobuf::int32 death_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static PlayPlayerScore* default_instance_;
};
// -------------------------------------------------------------------

class PeerList_PeerInfo : public ::google::protobuf::Message {
 public:
  PeerList_PeerInfo();
  virtual ~PeerList_PeerInfo();
  
  PeerList_PeerInfo(const PeerList_PeerInfo& from);
  
  inline PeerList_PeerInfo& operator=(const PeerList_PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerList_PeerInfo& default_instance();
  
  void Swap(PeerList_PeerInfo* other);
  
  // implements Message ----------------------------------------------
  
  PeerList_PeerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerList_PeerInfo& from);
  void MergeFrom(const PeerList_PeerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);
  
  // required bytes Info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.PeerList.PeerInfo)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_info();
  inline void clear_has_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* info_;
  ::google::protobuf::int32 serial_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static PeerList_PeerInfo* default_instance_;
};
// -------------------------------------------------------------------

class PeerList : public ::google::protobuf::Message {
 public:
  PeerList();
  virtual ~PeerList();
  
  PeerList(const PeerList& from);
  
  inline PeerList& operator=(const PeerList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerList& default_instance();
  
  void Swap(PeerList* other);
  
  // implements Message ----------------------------------------------
  
  PeerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerList& from);
  void MergeFrom(const PeerList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PeerList_PeerInfo PeerInfo;
  
  // accessors -------------------------------------------------------
  
  // repeated .SFPacketStore.PeerList.PeerInfo Peer = 10;
  inline int peer_size() const;
  inline void clear_peer();
  static const int kPeerFieldNumber = 10;
  inline const ::SFPacketStore::PeerList_PeerInfo& peer(int index) const;
  inline ::SFPacketStore::PeerList_PeerInfo* mutable_peer(int index);
  inline ::SFPacketStore::PeerList_PeerInfo* add_peer();
  inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >&
      peer() const;
  inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >*
      mutable_peer();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.PeerList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo > peer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static PeerList* default_instance_;
};
// -------------------------------------------------------------------

class MSG_CREATE_PLAYER : public ::google::protobuf::Message {
 public:
  MSG_CREATE_PLAYER();
  virtual ~MSG_CREATE_PLAYER();
  
  MSG_CREATE_PLAYER(const MSG_CREATE_PLAYER& from);
  
  inline MSG_CREATE_PLAYER& operator=(const MSG_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_CREATE_PLAYER& default_instance();
  
  void Swap(MSG_CREATE_PLAYER* other);
  
  // implements Message ----------------------------------------------
  
  MSG_CREATE_PLAYER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_CREATE_PLAYER& from);
  void MergeFrom(const MSG_CREATE_PLAYER& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);
  
  // required int32 spawnindex = 2;
  inline bool has_spawnindex() const;
  inline void clear_spawnindex();
  static const int kSpawnindexFieldNumber = 2;
  inline ::google::protobuf::int32 spawnindex() const;
  inline void set_spawnindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_CREATE_PLAYER)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_spawnindex();
  inline void clear_has_spawnindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 serial_;
  ::google::protobuf::int32 spawnindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_CREATE_PLAYER* default_instance_;
};
// -------------------------------------------------------------------

class MSG_DESTROY_PLAYER : public ::google::protobuf::Message {
 public:
  MSG_DESTROY_PLAYER();
  virtual ~MSG_DESTROY_PLAYER();
  
  MSG_DESTROY_PLAYER(const MSG_DESTROY_PLAYER& from);
  
  inline MSG_DESTROY_PLAYER& operator=(const MSG_DESTROY_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_DESTROY_PLAYER& default_instance();
  
  void Swap(MSG_DESTROY_PLAYER* other);
  
  // implements Message ----------------------------------------------
  
  MSG_DESTROY_PLAYER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_DESTROY_PLAYER& from);
  void MergeFrom(const MSG_DESTROY_PLAYER& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 Serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_DESTROY_PLAYER)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 serial_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_DESTROY_PLAYER* default_instance_;
};
// -------------------------------------------------------------------

class MSG_PLAYER_MOVE_UPDATE : public ::google::protobuf::Message {
 public:
  MSG_PLAYER_MOVE_UPDATE();
  virtual ~MSG_PLAYER_MOVE_UPDATE();
  
  MSG_PLAYER_MOVE_UPDATE(const MSG_PLAYER_MOVE_UPDATE& from);
  
  inline MSG_PLAYER_MOVE_UPDATE& operator=(const MSG_PLAYER_MOVE_UPDATE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_PLAYER_MOVE_UPDATE& default_instance();
  
  void Swap(MSG_PLAYER_MOVE_UPDATE* other);
  
  // implements Message ----------------------------------------------
  
  MSG_PLAYER_MOVE_UPDATE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_PLAYER_MOVE_UPDATE& from);
  void MergeFrom(const MSG_PLAYER_MOVE_UPDATE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes moveupdate = 1;
  inline bool has_moveupdate() const;
  inline void clear_moveupdate();
  static const int kMoveupdateFieldNumber = 1;
  inline const ::std::string& moveupdate() const;
  inline void set_moveupdate(const ::std::string& value);
  inline void set_moveupdate(const char* value);
  inline void set_moveupdate(const void* value, size_t size);
  inline ::std::string* mutable_moveupdate();
  inline ::std::string* release_moveupdate();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_PLAYER_MOVE_UPDATE)
 private:
  inline void set_has_moveupdate();
  inline void clear_has_moveupdate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* moveupdate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_PLAYER_MOVE_UPDATE* default_instance_;
};
// -------------------------------------------------------------------

class MSG_PLAYER_LOOK_UPDATE : public ::google::protobuf::Message {
 public:
  MSG_PLAYER_LOOK_UPDATE();
  virtual ~MSG_PLAYER_LOOK_UPDATE();
  
  MSG_PLAYER_LOOK_UPDATE(const MSG_PLAYER_LOOK_UPDATE& from);
  
  inline MSG_PLAYER_LOOK_UPDATE& operator=(const MSG_PLAYER_LOOK_UPDATE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_PLAYER_LOOK_UPDATE& default_instance();
  
  void Swap(MSG_PLAYER_LOOK_UPDATE* other);
  
  // implements Message ----------------------------------------------
  
  MSG_PLAYER_LOOK_UPDATE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_PLAYER_LOOK_UPDATE& from);
  void MergeFrom(const MSG_PLAYER_LOOK_UPDATE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes lookupdate = 1;
  inline bool has_lookupdate() const;
  inline void clear_lookupdate();
  static const int kLookupdateFieldNumber = 1;
  inline const ::std::string& lookupdate() const;
  inline void set_lookupdate(const ::std::string& value);
  inline void set_lookupdate(const char* value);
  inline void set_lookupdate(const void* value, size_t size);
  inline ::std::string* mutable_lookupdate();
  inline ::std::string* release_lookupdate();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_PLAYER_LOOK_UPDATE)
 private:
  inline void set_has_lookupdate();
  inline void clear_has_lookupdate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* lookupdate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_PLAYER_LOOK_UPDATE* default_instance_;
};
// -------------------------------------------------------------------

class MSG_PLAYER_HEALTH : public ::google::protobuf::Message {
 public:
  MSG_PLAYER_HEALTH();
  virtual ~MSG_PLAYER_HEALTH();
  
  MSG_PLAYER_HEALTH(const MSG_PLAYER_HEALTH& from);
  
  inline MSG_PLAYER_HEALTH& operator=(const MSG_PLAYER_HEALTH& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_PLAYER_HEALTH& default_instance();
  
  void Swap(MSG_PLAYER_HEALTH* other);
  
  // implements Message ----------------------------------------------
  
  MSG_PLAYER_HEALTH* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_PLAYER_HEALTH& from);
  void MergeFrom(const MSG_PLAYER_HEALTH& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes playerhealth = 1;
  inline bool has_playerhealth() const;
  inline void clear_playerhealth();
  static const int kPlayerhealthFieldNumber = 1;
  inline const ::std::string& playerhealth() const;
  inline void set_playerhealth(const ::std::string& value);
  inline void set_playerhealth(const char* value);
  inline void set_playerhealth(const void* value, size_t size);
  inline ::std::string* mutable_playerhealth();
  inline ::std::string* release_playerhealth();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_PLAYER_HEALTH)
 private:
  inline void set_has_playerhealth();
  inline void clear_has_playerhealth();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerhealth_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_PLAYER_HEALTH* default_instance_;
};
// -------------------------------------------------------------------

class MSG_PLAYER_SCORE : public ::google::protobuf::Message {
 public:
  MSG_PLAYER_SCORE();
  virtual ~MSG_PLAYER_SCORE();
  
  MSG_PLAYER_SCORE(const MSG_PLAYER_SCORE& from);
  
  inline MSG_PLAYER_SCORE& operator=(const MSG_PLAYER_SCORE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_PLAYER_SCORE& default_instance();
  
  void Swap(MSG_PLAYER_SCORE* other);
  
  // implements Message ----------------------------------------------
  
  MSG_PLAYER_SCORE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_PLAYER_SCORE& from);
  void MergeFrom(const MSG_PLAYER_SCORE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes PlayerScore = 1;
  inline bool has_playerscore() const;
  inline void clear_playerscore();
  static const int kPlayerScoreFieldNumber = 1;
  inline const ::std::string& playerscore() const;
  inline void set_playerscore(const ::std::string& value);
  inline void set_playerscore(const char* value);
  inline void set_playerscore(const void* value, size_t size);
  inline ::std::string* mutable_playerscore();
  inline ::std::string* release_playerscore();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_PLAYER_SCORE)
 private:
  inline void set_has_playerscore();
  inline void clear_has_playerscore();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerscore_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_PLAYER_SCORE* default_instance_;
};
// -------------------------------------------------------------------

class MSG_PLAYER_WEAPON_CHANGE : public ::google::protobuf::Message {
 public:
  MSG_PLAYER_WEAPON_CHANGE();
  virtual ~MSG_PLAYER_WEAPON_CHANGE();
  
  MSG_PLAYER_WEAPON_CHANGE(const MSG_PLAYER_WEAPON_CHANGE& from);
  
  inline MSG_PLAYER_WEAPON_CHANGE& operator=(const MSG_PLAYER_WEAPON_CHANGE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_PLAYER_WEAPON_CHANGE& default_instance();
  
  void Swap(MSG_PLAYER_WEAPON_CHANGE* other);
  
  // implements Message ----------------------------------------------
  
  MSG_PLAYER_WEAPON_CHANGE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_PLAYER_WEAPON_CHANGE& from);
  void MergeFrom(const MSG_PLAYER_WEAPON_CHANGE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes WeaponChange = 1;
  inline bool has_weaponchange() const;
  inline void clear_weaponchange();
  static const int kWeaponChangeFieldNumber = 1;
  inline const ::std::string& weaponchange() const;
  inline void set_weaponchange(const ::std::string& value);
  inline void set_weaponchange(const char* value);
  inline void set_weaponchange(const void* value, size_t size);
  inline ::std::string* mutable_weaponchange();
  inline ::std::string* release_weaponchange();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_PLAYER_WEAPON_CHANGE)
 private:
  inline void set_has_weaponchange();
  inline void clear_has_weaponchange();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* weaponchange_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_PLAYER_WEAPON_CHANGE* default_instance_;
};
// -------------------------------------------------------------------

class MSG_PLAYER_WEAPON_CHANGING : public ::google::protobuf::Message {
 public:
  MSG_PLAYER_WEAPON_CHANGING();
  virtual ~MSG_PLAYER_WEAPON_CHANGING();
  
  MSG_PLAYER_WEAPON_CHANGING(const MSG_PLAYER_WEAPON_CHANGING& from);
  
  inline MSG_PLAYER_WEAPON_CHANGING& operator=(const MSG_PLAYER_WEAPON_CHANGING& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_PLAYER_WEAPON_CHANGING& default_instance();
  
  void Swap(MSG_PLAYER_WEAPON_CHANGING* other);
  
  // implements Message ----------------------------------------------
  
  MSG_PLAYER_WEAPON_CHANGING* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_PLAYER_WEAPON_CHANGING& from);
  void MergeFrom(const MSG_PLAYER_WEAPON_CHANGING& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes WeaponChanging = 1;
  inline bool has_weaponchanging() const;
  inline void clear_weaponchanging();
  static const int kWeaponChangingFieldNumber = 1;
  inline const ::std::string& weaponchanging() const;
  inline void set_weaponchanging(const ::std::string& value);
  inline void set_weaponchanging(const char* value);
  inline void set_weaponchanging(const void* value, size_t size);
  inline ::std::string* mutable_weaponchanging();
  inline ::std::string* release_weaponchanging();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_PLAYER_WEAPON_CHANGING)
 private:
  inline void set_has_weaponchanging();
  inline void clear_has_weaponchanging();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* weaponchanging_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_PLAYER_WEAPON_CHANGING* default_instance_;
};
// -------------------------------------------------------------------

class MSG_SPAWN_PLAYER : public ::google::protobuf::Message {
 public:
  MSG_SPAWN_PLAYER();
  virtual ~MSG_SPAWN_PLAYER();
  
  MSG_SPAWN_PLAYER(const MSG_SPAWN_PLAYER& from);
  
  inline MSG_SPAWN_PLAYER& operator=(const MSG_SPAWN_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_SPAWN_PLAYER& default_instance();
  
  void Swap(MSG_SPAWN_PLAYER* other);
  
  // implements Message ----------------------------------------------
  
  MSG_SPAWN_PLAYER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_SPAWN_PLAYER& from);
  void MergeFrom(const MSG_SPAWN_PLAYER& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes SpawnPlayer = 1;
  inline bool has_spawnplayer() const;
  inline void clear_spawnplayer();
  static const int kSpawnPlayerFieldNumber = 1;
  inline const ::std::string& spawnplayer() const;
  inline void set_spawnplayer(const ::std::string& value);
  inline void set_spawnplayer(const char* value);
  inline void set_spawnplayer(const void* value, size_t size);
  inline ::std::string* mutable_spawnplayer();
  inline ::std::string* release_spawnplayer();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_SPAWN_PLAYER)
 private:
  inline void set_has_spawnplayer();
  inline void clear_has_spawnplayer();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* spawnplayer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static MSG_SPAWN_PLAYER* default_instance_;
};
// -------------------------------------------------------------------

class PLAYER_IP : public ::google::protobuf::Message {
 public:
  PLAYER_IP();
  virtual ~PLAYER_IP();
  
  PLAYER_IP(const PLAYER_IP& from);
  
  inline PLAYER_IP& operator=(const PLAYER_IP& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PLAYER_IP& default_instance();
  
  void Swap(PLAYER_IP* other);
  
  // implements Message ----------------------------------------------
  
  PLAYER_IP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PLAYER_IP& from);
  void MergeFrom(const PLAYER_IP& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes playerip = 1;
  inline bool has_playerip() const;
  inline void clear_playerip();
  static const int kPlayeripFieldNumber = 1;
  inline const ::std::string& playerip() const;
  inline void set_playerip(const ::std::string& value);
  inline void set_playerip(const char* value);
  inline void set_playerip(const void* value, size_t size);
  inline ::std::string* mutable_playerip();
  inline ::std::string* release_playerip();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.PLAYER_IP)
 private:
  inline void set_has_playerip();
  inline void clear_has_playerip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* playerip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static PLAYER_IP* default_instance_;
};
// -------------------------------------------------------------------

class ADD_PEER : public ::google::protobuf::Message {
 public:
  ADD_PEER();
  virtual ~ADD_PEER();
  
  ADD_PEER(const ADD_PEER& from);
  
  inline ADD_PEER& operator=(const ADD_PEER& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ADD_PEER& default_instance();
  
  void Swap(ADD_PEER* other);
  
  // implements Message ----------------------------------------------
  
  ADD_PEER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ADD_PEER& from);
  void MergeFrom(const ADD_PEER& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes addpeer = 1;
  inline bool has_addpeer() const;
  inline void clear_addpeer();
  static const int kAddpeerFieldNumber = 1;
  inline const ::std::string& addpeer() const;
  inline void set_addpeer(const ::std::string& value);
  inline void set_addpeer(const char* value);
  inline void set_addpeer(const void* value, size_t size);
  inline ::std::string* mutable_addpeer();
  inline ::std::string* release_addpeer();
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.ADD_PEER)
 private:
  inline void set_has_addpeer();
  inline void clear_has_addpeer();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* addpeer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static ADD_PEER* default_instance_;
};
// -------------------------------------------------------------------

class DELETE_PEER : public ::google::protobuf::Message {
 public:
  DELETE_PEER();
  virtual ~DELETE_PEER();
  
  DELETE_PEER(const DELETE_PEER& from);
  
  inline DELETE_PEER& operator=(const DELETE_PEER& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DELETE_PEER& default_instance();
  
  void Swap(DELETE_PEER* other);
  
  // implements Message ----------------------------------------------
  
  DELETE_PEER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DELETE_PEER& from);
  void MergeFrom(const DELETE_PEER& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:SFPacketStore.DELETE_PEER)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 serial_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();
  
  void InitAsDefaultInstance();
  static DELETE_PEER* default_instance_;
};
// ===================================================================


// ===================================================================

// Login

// required string UserName = 1;
inline bool Login::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Login::username() const {
  return *username_;
}
inline void Login::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Login::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Password = 2;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  return *password_;
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginSuccess

// required int32 Result = 1;
inline bool LoginSuccess::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginSuccess::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginSuccess::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginSuccess::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginSuccess::result() const {
  return result_;
}
inline void LoginSuccess::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required bytes UserInfo = 2;
inline bool LoginSuccess::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginSuccess::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginSuccess::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginSuccess::clear_userinfo() {
  if (userinfo_ != &::google::protobuf::internal::kEmptyString) {
    userinfo_->clear();
  }
  clear_has_userinfo();
}
inline const ::std::string& LoginSuccess::userinfo() const {
  return *userinfo_;
}
inline void LoginSuccess::set_userinfo(const ::std::string& value) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(value);
}
inline void LoginSuccess::set_userinfo(const char* value) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(value);
}
inline void LoginSuccess::set_userinfo(const void* value, size_t size) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginSuccess::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  return userinfo_;
}
inline ::std::string* LoginSuccess::release_userinfo() {
  clear_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userinfo_;
    userinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginFail

// required int32 Result = 1;
inline bool LoginFail::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginFail::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginFail::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginFail::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginFail::result() const {
  return result_;
}
inline void LoginFail::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// TeamInfo_TeamMember

// required string Member = 1;
inline bool TeamInfo_TeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamInfo_TeamMember::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamInfo_TeamMember::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamInfo_TeamMember::clear_member() {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    member_->clear();
  }
  clear_has_member();
}
inline const ::std::string& TeamInfo_TeamMember::member() const {
  return *member_;
}
inline void TeamInfo_TeamMember::set_member(const ::std::string& value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void TeamInfo_TeamMember::set_member(const char* value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void TeamInfo_TeamMember::set_member(const char* value, size_t size) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamInfo_TeamMember::mutable_member() {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  return member_;
}
inline ::std::string* TeamInfo_TeamMember::release_member() {
  clear_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = member_;
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TeamInfo

// required .SFPacketStore.TeamType Type = 1 [default = RED];
inline bool TeamInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline SFPacketStore::TeamType TeamInfo::type() const {
  return static_cast< SFPacketStore::TeamType >(type_);
}
inline void TeamInfo::set_type(SFPacketStore::TeamType value) {
  GOOGLE_DCHECK(SFPacketStore::TeamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .SFPacketStore.TeamInfo.TeamMember Member = 6;
inline int TeamInfo::member_size() const {
  return member_.size();
}
inline void TeamInfo::clear_member() {
  member_.Clear();
}
inline const ::SFPacketStore::TeamInfo_TeamMember& TeamInfo::member(int index) const {
  return member_.Get(index);
}
inline ::SFPacketStore::TeamInfo_TeamMember* TeamInfo::mutable_member(int index) {
  return member_.Mutable(index);
}
inline ::SFPacketStore::TeamInfo_TeamMember* TeamInfo::add_member() {
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >&
TeamInfo::member() const {
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >*
TeamInfo::mutable_member() {
  return &member_;
}

// -------------------------------------------------------------------

// EnterTeamMember

// required string Member = 1;
inline bool EnterTeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterTeamMember::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterTeamMember::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterTeamMember::clear_member() {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    member_->clear();
  }
  clear_has_member();
}
inline const ::std::string& EnterTeamMember::member() const {
  return *member_;
}
inline void EnterTeamMember::set_member(const ::std::string& value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void EnterTeamMember::set_member(const char* value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void EnterTeamMember::set_member(const char* value, size_t size) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterTeamMember::mutable_member() {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  return member_;
}
inline ::std::string* EnterTeamMember::release_member() {
  clear_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = member_;
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .SFPacketStore.TeamType Type = 2;
inline bool EnterTeamMember::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterTeamMember::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterTeamMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterTeamMember::clear_type() {
  type_ = -1;
  clear_has_type();
}
inline SFPacketStore::TeamType EnterTeamMember::type() const {
  return static_cast< SFPacketStore::TeamType >(type_);
}
inline void EnterTeamMember::set_type(SFPacketStore::TeamType value) {
  GOOGLE_DCHECK(SFPacketStore::TeamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// LeaveTeamMember

// required string Member = 1;
inline bool LeaveTeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveTeamMember::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveTeamMember::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveTeamMember::clear_member() {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    member_->clear();
  }
  clear_has_member();
}
inline const ::std::string& LeaveTeamMember::member() const {
  return *member_;
}
inline void LeaveTeamMember::set_member(const ::std::string& value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void LeaveTeamMember::set_member(const char* value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void LeaveTeamMember::set_member(const char* value, size_t size) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveTeamMember::mutable_member() {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  return member_;
}
inline ::std::string* LeaveTeamMember::release_member() {
  clear_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = member_;
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .SFPacketStore.TeamType Type = 2;
inline bool LeaveTeamMember::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveTeamMember::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveTeamMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveTeamMember::clear_type() {
  type_ = -1;
  clear_has_type();
}
inline SFPacketStore::TeamType LeaveTeamMember::type() const {
  return static_cast< SFPacketStore::TeamType >(type_);
}
inline void LeaveTeamMember::set_type(SFPacketStore::TeamType value) {
  GOOGLE_DCHECK(SFPacketStore::TeamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// InvalidPacket

// required string Arg = 1;
inline bool InvalidPacket::has_arg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvalidPacket::set_has_arg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvalidPacket::clear_has_arg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvalidPacket::clear_arg() {
  if (arg_ != &::google::protobuf::internal::kEmptyString) {
    arg_->clear();
  }
  clear_has_arg();
}
inline const ::std::string& InvalidPacket::arg() const {
  return *arg_;
}
inline void InvalidPacket::set_arg(const ::std::string& value) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    arg_ = new ::std::string;
  }
  arg_->assign(value);
}
inline void InvalidPacket::set_arg(const char* value) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    arg_ = new ::std::string;
  }
  arg_->assign(value);
}
inline void InvalidPacket::set_arg(const char* value, size_t size) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    arg_ = new ::std::string;
  }
  arg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvalidPacket::mutable_arg() {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    arg_ = new ::std::string;
  }
  return arg_;
}
inline ::std::string* InvalidPacket::release_arg() {
  clear_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arg_;
    arg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// EnterLobby

// optional int32 LobbyIndex = 1 [default = 0];
inline bool EnterLobby::has_lobbyindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterLobby::set_has_lobbyindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterLobby::clear_has_lobbyindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterLobby::clear_lobbyindex() {
  lobbyindex_ = 0;
  clear_has_lobbyindex();
}
inline ::google::protobuf::int32 EnterLobby::lobbyindex() const {
  return lobbyindex_;
}
inline void EnterLobby::set_lobbyindex(::google::protobuf::int32 value) {
  set_has_lobbyindex();
  lobbyindex_ = value;
}

// -------------------------------------------------------------------

// ChatReq

// required string Message = 1 [default = "\270\336\274\274\301\366\270\246 \263\326\300\270\274\274\277\344"];
inline bool ChatReq::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReq::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReq::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReq::clear_message() {
  if (message_ != &_default_message_) {
    message_->assign(_default_message_);
  }
  clear_has_message();
}
inline const ::std::string& ChatReq::message() const {
  return *message_;
}
inline void ChatReq::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatReq::set_message(const char* value) {
  set_has_message();
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatReq::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatReq::mutable_message() {
  set_has_message();
  if (message_ == &_default_message_) {
    message_ = new ::std::string(_default_message_);
  }
  return message_;
}
inline ::std::string* ChatReq::release_message() {
  clear_has_message();
  if (message_ == &_default_message_) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&_default_message_);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChatRes

// required string Sender = 1;
inline bool ChatRes::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRes::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRes::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRes::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& ChatRes::sender() const {
  return *sender_;
}
inline void ChatRes::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ChatRes::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ChatRes::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRes::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* ChatRes::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Message = 2 [default = "\270\336\274\274\301\366\270\246 \263\326\300\270\274\274\277\344"];
inline bool ChatRes::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRes::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRes::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRes::clear_message() {
  if (message_ != &_default_message_) {
    message_->assign(_default_message_);
  }
  clear_has_message();
}
inline const ::std::string& ChatRes::message() const {
  return *message_;
}
inline void ChatRes::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatRes::set_message(const char* value) {
  set_has_message();
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatRes::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &_default_message_) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRes::mutable_message() {
  set_has_message();
  if (message_ == &_default_message_) {
    message_ = new ::std::string(_default_message_);
  }
  return message_;
}
inline ::std::string* ChatRes::release_message() {
  clear_has_message();
  if (message_ == &_default_message_) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&_default_message_);
    return temp;
  }
}

// -------------------------------------------------------------------

// EnterRoom

// required int32 RoomIndex = 1;
inline bool EnterRoom::has_roomindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoom::set_has_roomindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoom::clear_has_roomindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoom::clear_roomindex() {
  roomindex_ = 0;
  clear_has_roomindex();
}
inline ::google::protobuf::int32 EnterRoom::roomindex() const {
  return roomindex_;
}
inline void EnterRoom::set_roomindex(::google::protobuf::int32 value) {
  set_has_roomindex();
  roomindex_ = value;
}

// required int32 GameMode = 2;
inline bool EnterRoom::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoom::set_has_gamemode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoom::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoom::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 EnterRoom::gamemode() const {
  return gamemode_;
}
inline void EnterRoom::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// optional string Password = 3 [default = "None"];
inline bool EnterRoom::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoom::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoom::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoom::clear_password() {
  if (password_ != &_default_password_) {
    password_->assign(_default_password_);
  }
  clear_has_password();
}
inline const ::std::string& EnterRoom::password() const {
  return *password_;
}
inline void EnterRoom::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void EnterRoom::set_password(const char* value) {
  set_has_password();
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void EnterRoom::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoom::mutable_password() {
  set_has_password();
  if (password_ == &_default_password_) {
    password_ = new ::std::string(_default_password_);
  }
  return password_;
}
inline ::std::string* EnterRoom::release_password() {
  clear_has_password();
  if (password_ == &_default_password_) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&_default_password_);
    return temp;
  }
}

// -------------------------------------------------------------------

// CreateRoom

// required int32 GameMode = 1;
inline bool CreateRoom::has_gamemode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoom::set_has_gamemode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoom::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoom::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 CreateRoom::gamemode() const {
  return gamemode_;
}
inline void CreateRoom::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// optional string Password = 2 [default = "None"];
inline bool CreateRoom::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoom::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoom::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoom::clear_password() {
  if (password_ != &_default_password_) {
    password_->assign(_default_password_);
  }
  clear_has_password();
}
inline const ::std::string& CreateRoom::password() const {
  return *password_;
}
inline void CreateRoom::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CreateRoom::set_password(const char* value) {
  set_has_password();
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CreateRoom::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoom::mutable_password() {
  set_has_password();
  if (password_ == &_default_password_) {
    password_ = new ::std::string(_default_password_);
  }
  return password_;
}
inline ::std::string* CreateRoom::release_password() {
  clear_has_password();
  if (password_ == &_default_password_) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&_default_password_);
    return temp;
  }
}

// -------------------------------------------------------------------

// LeaveRoom

// optional int32 Reason = 1 [default = 0];
inline bool LeaveRoom::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveRoom::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveRoom::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveRoom::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 LeaveRoom::reason() const {
  return reason_;
}
inline void LeaveRoom::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// RoomList_RoomInfo

// required string RoomName = 1;
inline bool RoomList_RoomInfo::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomList_RoomInfo::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomList_RoomInfo::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomList_RoomInfo::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& RoomList_RoomInfo::roomname() const {
  return *roomname_;
}
inline void RoomList_RoomInfo::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void RoomList_RoomInfo::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void RoomList_RoomInfo::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomList_RoomInfo::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* RoomList_RoomInfo::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string RoomChief = 2;
inline bool RoomList_RoomInfo::has_roomchief() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomList_RoomInfo::set_has_roomchief() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomList_RoomInfo::clear_has_roomchief() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomList_RoomInfo::clear_roomchief() {
  if (roomchief_ != &::google::protobuf::internal::kEmptyString) {
    roomchief_->clear();
  }
  clear_has_roomchief();
}
inline const ::std::string& RoomList_RoomInfo::roomchief() const {
  return *roomchief_;
}
inline void RoomList_RoomInfo::set_roomchief(const ::std::string& value) {
  set_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    roomchief_ = new ::std::string;
  }
  roomchief_->assign(value);
}
inline void RoomList_RoomInfo::set_roomchief(const char* value) {
  set_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    roomchief_ = new ::std::string;
  }
  roomchief_->assign(value);
}
inline void RoomList_RoomInfo::set_roomchief(const char* value, size_t size) {
  set_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    roomchief_ = new ::std::string;
  }
  roomchief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomList_RoomInfo::mutable_roomchief() {
  set_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    roomchief_ = new ::std::string;
  }
  return roomchief_;
}
inline ::std::string* RoomList_RoomInfo::release_roomchief() {
  clear_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomchief_;
    roomchief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 UserCount = 3;
inline bool RoomList_RoomInfo::has_usercount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomList_RoomInfo::set_has_usercount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomList_RoomInfo::clear_has_usercount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomList_RoomInfo::clear_usercount() {
  usercount_ = 0;
  clear_has_usercount();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::usercount() const {
  return usercount_;
}
inline void RoomList_RoomInfo::set_usercount(::google::protobuf::int32 value) {
  set_has_usercount();
  usercount_ = value;
}

// required int32 MaxUserCount = 4;
inline bool RoomList_RoomInfo::has_maxusercount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomList_RoomInfo::set_has_maxusercount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomList_RoomInfo::clear_has_maxusercount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomList_RoomInfo::clear_maxusercount() {
  maxusercount_ = 0;
  clear_has_maxusercount();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::maxusercount() const {
  return maxusercount_;
}
inline void RoomList_RoomInfo::set_maxusercount(::google::protobuf::int32 value) {
  set_has_maxusercount();
  maxusercount_ = value;
}

// required int32 NeedPassword = 5;
inline bool RoomList_RoomInfo::has_needpassword() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomList_RoomInfo::set_has_needpassword() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomList_RoomInfo::clear_has_needpassword() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomList_RoomInfo::clear_needpassword() {
  needpassword_ = 0;
  clear_has_needpassword();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::needpassword() const {
  return needpassword_;
}
inline void RoomList_RoomInfo::set_needpassword(::google::protobuf::int32 value) {
  set_has_needpassword();
  needpassword_ = value;
}

// required int32 GameMode = 6;
inline bool RoomList_RoomInfo::has_gamemode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomList_RoomInfo::set_has_gamemode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomList_RoomInfo::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomList_RoomInfo::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::gamemode() const {
  return gamemode_;
}
inline void RoomList_RoomInfo::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// -------------------------------------------------------------------

// RoomList

// repeated .SFPacketStore.RoomList.RoomInfo Info = 10;
inline int RoomList::info_size() const {
  return info_.size();
}
inline void RoomList::clear_info() {
  info_.Clear();
}
inline const ::SFPacketStore::RoomList_RoomInfo& RoomList::info(int index) const {
  return info_.Get(index);
}
inline ::SFPacketStore::RoomList_RoomInfo* RoomList::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::SFPacketStore::RoomList_RoomInfo* RoomList::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >&
RoomList::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >*
RoomList::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// ChangeTeam

// -------------------------------------------------------------------

// StartGame

// -------------------------------------------------------------------

// LoadingComplete

// -------------------------------------------------------------------

// PlayStart

// -------------------------------------------------------------------

// PlayMove

// required float PosX = 1;
inline bool PlayMove::has_posx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayMove::set_has_posx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayMove::clear_has_posx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayMove::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float PlayMove::posx() const {
  return posx_;
}
inline void PlayMove::set_posx(float value) {
  set_has_posx();
  posx_ = value;
}

// required float PosY = 2;
inline bool PlayMove::has_posy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayMove::set_has_posy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayMove::clear_has_posy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayMove::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float PlayMove::posy() const {
  return posy_;
}
inline void PlayMove::set_posy(float value) {
  set_has_posy();
  posy_ = value;
}

// required float PosZ = 3;
inline bool PlayMove::has_posz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayMove::set_has_posz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayMove::clear_has_posz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayMove::clear_posz() {
  posz_ = 0;
  clear_has_posz();
}
inline float PlayMove::posz() const {
  return posz_;
}
inline void PlayMove::set_posz(float value) {
  set_has_posz();
  posz_ = value;
}

// -------------------------------------------------------------------

// PlayEnd

// -------------------------------------------------------------------

// PlayScoreInfo

// required int32 RedKillCount = 1;
inline bool PlayScoreInfo::has_redkillcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayScoreInfo::set_has_redkillcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayScoreInfo::clear_has_redkillcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayScoreInfo::clear_redkillcount() {
  redkillcount_ = 0;
  clear_has_redkillcount();
}
inline ::google::protobuf::int32 PlayScoreInfo::redkillcount() const {
  return redkillcount_;
}
inline void PlayScoreInfo::set_redkillcount(::google::protobuf::int32 value) {
  set_has_redkillcount();
  redkillcount_ = value;
}

// required int32 BlueKillCount = 2;
inline bool PlayScoreInfo::has_bluekillcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayScoreInfo::set_has_bluekillcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayScoreInfo::clear_has_bluekillcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayScoreInfo::clear_bluekillcount() {
  bluekillcount_ = 0;
  clear_has_bluekillcount();
}
inline ::google::protobuf::int32 PlayScoreInfo::bluekillcount() const {
  return bluekillcount_;
}
inline void PlayScoreInfo::set_bluekillcount(::google::protobuf::int32 value) {
  set_has_bluekillcount();
  bluekillcount_ = value;
}

// -------------------------------------------------------------------

// PlayPlayerScore

// required string name = 1;
inline bool PlayPlayerScore::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayPlayerScore::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayPlayerScore::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayPlayerScore::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayPlayerScore::name() const {
  return *name_;
}
inline void PlayPlayerScore::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayPlayerScore::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayPlayerScore::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayPlayerScore::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlayPlayerScore::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 teamtype = 2;
inline bool PlayPlayerScore::has_teamtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayPlayerScore::set_has_teamtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayPlayerScore::clear_has_teamtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayPlayerScore::clear_teamtype() {
  teamtype_ = 0;
  clear_has_teamtype();
}
inline ::google::protobuf::int32 PlayPlayerScore::teamtype() const {
  return teamtype_;
}
inline void PlayPlayerScore::set_teamtype(::google::protobuf::int32 value) {
  set_has_teamtype();
  teamtype_ = value;
}

// required int32 kill = 3;
inline bool PlayPlayerScore::has_kill() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayPlayerScore::set_has_kill() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayPlayerScore::clear_has_kill() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayPlayerScore::clear_kill() {
  kill_ = 0;
  clear_has_kill();
}
inline ::google::protobuf::int32 PlayPlayerScore::kill() const {
  return kill_;
}
inline void PlayPlayerScore::set_kill(::google::protobuf::int32 value) {
  set_has_kill();
  kill_ = value;
}

// required int32 death = 4;
inline bool PlayPlayerScore::has_death() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayPlayerScore::set_has_death() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayPlayerScore::clear_has_death() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayPlayerScore::clear_death() {
  death_ = 0;
  clear_has_death();
}
inline ::google::protobuf::int32 PlayPlayerScore::death() const {
  return death_;
}
inline void PlayPlayerScore::set_death(::google::protobuf::int32 value) {
  set_has_death();
  death_ = value;
}

// -------------------------------------------------------------------

// PeerList_PeerInfo

// required int32 serial = 1;
inline bool PeerList_PeerInfo::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeerList_PeerInfo::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeerList_PeerInfo::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeerList_PeerInfo::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 PeerList_PeerInfo::serial() const {
  return serial_;
}
inline void PeerList_PeerInfo::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// required bytes Info = 2;
inline bool PeerList_PeerInfo::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerList_PeerInfo::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerList_PeerInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerList_PeerInfo::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& PeerList_PeerInfo::info() const {
  return *info_;
}
inline void PeerList_PeerInfo::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void PeerList_PeerInfo::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void PeerList_PeerInfo::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PeerList_PeerInfo::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* PeerList_PeerInfo::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PeerList

// repeated .SFPacketStore.PeerList.PeerInfo Peer = 10;
inline int PeerList::peer_size() const {
  return peer_.size();
}
inline void PeerList::clear_peer() {
  peer_.Clear();
}
inline const ::SFPacketStore::PeerList_PeerInfo& PeerList::peer(int index) const {
  return peer_.Get(index);
}
inline ::SFPacketStore::PeerList_PeerInfo* PeerList::mutable_peer(int index) {
  return peer_.Mutable(index);
}
inline ::SFPacketStore::PeerList_PeerInfo* PeerList::add_peer() {
  return peer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >&
PeerList::peer() const {
  return peer_;
}
inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >*
PeerList::mutable_peer() {
  return &peer_;
}

// -------------------------------------------------------------------

// MSG_CREATE_PLAYER

// required int32 Serial = 1;
inline bool MSG_CREATE_PLAYER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_CREATE_PLAYER::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_CREATE_PLAYER::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_CREATE_PLAYER::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 MSG_CREATE_PLAYER::serial() const {
  return serial_;
}
inline void MSG_CREATE_PLAYER::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// required int32 spawnindex = 2;
inline bool MSG_CREATE_PLAYER::has_spawnindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MSG_CREATE_PLAYER::set_has_spawnindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MSG_CREATE_PLAYER::clear_has_spawnindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MSG_CREATE_PLAYER::clear_spawnindex() {
  spawnindex_ = 0;
  clear_has_spawnindex();
}
inline ::google::protobuf::int32 MSG_CREATE_PLAYER::spawnindex() const {
  return spawnindex_;
}
inline void MSG_CREATE_PLAYER::set_spawnindex(::google::protobuf::int32 value) {
  set_has_spawnindex();
  spawnindex_ = value;
}

// -------------------------------------------------------------------

// MSG_DESTROY_PLAYER

// required int32 Serial = 1;
inline bool MSG_DESTROY_PLAYER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_DESTROY_PLAYER::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_DESTROY_PLAYER::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_DESTROY_PLAYER::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 MSG_DESTROY_PLAYER::serial() const {
  return serial_;
}
inline void MSG_DESTROY_PLAYER::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// -------------------------------------------------------------------

// MSG_PLAYER_MOVE_UPDATE

// required bytes moveupdate = 1;
inline bool MSG_PLAYER_MOVE_UPDATE::has_moveupdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_PLAYER_MOVE_UPDATE::set_has_moveupdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_PLAYER_MOVE_UPDATE::clear_has_moveupdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_PLAYER_MOVE_UPDATE::clear_moveupdate() {
  if (moveupdate_ != &::google::protobuf::internal::kEmptyString) {
    moveupdate_->clear();
  }
  clear_has_moveupdate();
}
inline const ::std::string& MSG_PLAYER_MOVE_UPDATE::moveupdate() const {
  return *moveupdate_;
}
inline void MSG_PLAYER_MOVE_UPDATE::set_moveupdate(const ::std::string& value) {
  set_has_moveupdate();
  if (moveupdate_ == &::google::protobuf::internal::kEmptyString) {
    moveupdate_ = new ::std::string;
  }
  moveupdate_->assign(value);
}
inline void MSG_PLAYER_MOVE_UPDATE::set_moveupdate(const char* value) {
  set_has_moveupdate();
  if (moveupdate_ == &::google::protobuf::internal::kEmptyString) {
    moveupdate_ = new ::std::string;
  }
  moveupdate_->assign(value);
}
inline void MSG_PLAYER_MOVE_UPDATE::set_moveupdate(const void* value, size_t size) {
  set_has_moveupdate();
  if (moveupdate_ == &::google::protobuf::internal::kEmptyString) {
    moveupdate_ = new ::std::string;
  }
  moveupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_PLAYER_MOVE_UPDATE::mutable_moveupdate() {
  set_has_moveupdate();
  if (moveupdate_ == &::google::protobuf::internal::kEmptyString) {
    moveupdate_ = new ::std::string;
  }
  return moveupdate_;
}
inline ::std::string* MSG_PLAYER_MOVE_UPDATE::release_moveupdate() {
  clear_has_moveupdate();
  if (moveupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moveupdate_;
    moveupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MSG_PLAYER_LOOK_UPDATE

// required bytes lookupdate = 1;
inline bool MSG_PLAYER_LOOK_UPDATE::has_lookupdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_PLAYER_LOOK_UPDATE::set_has_lookupdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_PLAYER_LOOK_UPDATE::clear_has_lookupdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_PLAYER_LOOK_UPDATE::clear_lookupdate() {
  if (lookupdate_ != &::google::protobuf::internal::kEmptyString) {
    lookupdate_->clear();
  }
  clear_has_lookupdate();
}
inline const ::std::string& MSG_PLAYER_LOOK_UPDATE::lookupdate() const {
  return *lookupdate_;
}
inline void MSG_PLAYER_LOOK_UPDATE::set_lookupdate(const ::std::string& value) {
  set_has_lookupdate();
  if (lookupdate_ == &::google::protobuf::internal::kEmptyString) {
    lookupdate_ = new ::std::string;
  }
  lookupdate_->assign(value);
}
inline void MSG_PLAYER_LOOK_UPDATE::set_lookupdate(const char* value) {
  set_has_lookupdate();
  if (lookupdate_ == &::google::protobuf::internal::kEmptyString) {
    lookupdate_ = new ::std::string;
  }
  lookupdate_->assign(value);
}
inline void MSG_PLAYER_LOOK_UPDATE::set_lookupdate(const void* value, size_t size) {
  set_has_lookupdate();
  if (lookupdate_ == &::google::protobuf::internal::kEmptyString) {
    lookupdate_ = new ::std::string;
  }
  lookupdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_PLAYER_LOOK_UPDATE::mutable_lookupdate() {
  set_has_lookupdate();
  if (lookupdate_ == &::google::protobuf::internal::kEmptyString) {
    lookupdate_ = new ::std::string;
  }
  return lookupdate_;
}
inline ::std::string* MSG_PLAYER_LOOK_UPDATE::release_lookupdate() {
  clear_has_lookupdate();
  if (lookupdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lookupdate_;
    lookupdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MSG_PLAYER_HEALTH

// required bytes playerhealth = 1;
inline bool MSG_PLAYER_HEALTH::has_playerhealth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_PLAYER_HEALTH::set_has_playerhealth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_PLAYER_HEALTH::clear_has_playerhealth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_PLAYER_HEALTH::clear_playerhealth() {
  if (playerhealth_ != &::google::protobuf::internal::kEmptyString) {
    playerhealth_->clear();
  }
  clear_has_playerhealth();
}
inline const ::std::string& MSG_PLAYER_HEALTH::playerhealth() const {
  return *playerhealth_;
}
inline void MSG_PLAYER_HEALTH::set_playerhealth(const ::std::string& value) {
  set_has_playerhealth();
  if (playerhealth_ == &::google::protobuf::internal::kEmptyString) {
    playerhealth_ = new ::std::string;
  }
  playerhealth_->assign(value);
}
inline void MSG_PLAYER_HEALTH::set_playerhealth(const char* value) {
  set_has_playerhealth();
  if (playerhealth_ == &::google::protobuf::internal::kEmptyString) {
    playerhealth_ = new ::std::string;
  }
  playerhealth_->assign(value);
}
inline void MSG_PLAYER_HEALTH::set_playerhealth(const void* value, size_t size) {
  set_has_playerhealth();
  if (playerhealth_ == &::google::protobuf::internal::kEmptyString) {
    playerhealth_ = new ::std::string;
  }
  playerhealth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_PLAYER_HEALTH::mutable_playerhealth() {
  set_has_playerhealth();
  if (playerhealth_ == &::google::protobuf::internal::kEmptyString) {
    playerhealth_ = new ::std::string;
  }
  return playerhealth_;
}
inline ::std::string* MSG_PLAYER_HEALTH::release_playerhealth() {
  clear_has_playerhealth();
  if (playerhealth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerhealth_;
    playerhealth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MSG_PLAYER_SCORE

// required bytes PlayerScore = 1;
inline bool MSG_PLAYER_SCORE::has_playerscore() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_PLAYER_SCORE::set_has_playerscore() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_PLAYER_SCORE::clear_has_playerscore() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_PLAYER_SCORE::clear_playerscore() {
  if (playerscore_ != &::google::protobuf::internal::kEmptyString) {
    playerscore_->clear();
  }
  clear_has_playerscore();
}
inline const ::std::string& MSG_PLAYER_SCORE::playerscore() const {
  return *playerscore_;
}
inline void MSG_PLAYER_SCORE::set_playerscore(const ::std::string& value) {
  set_has_playerscore();
  if (playerscore_ == &::google::protobuf::internal::kEmptyString) {
    playerscore_ = new ::std::string;
  }
  playerscore_->assign(value);
}
inline void MSG_PLAYER_SCORE::set_playerscore(const char* value) {
  set_has_playerscore();
  if (playerscore_ == &::google::protobuf::internal::kEmptyString) {
    playerscore_ = new ::std::string;
  }
  playerscore_->assign(value);
}
inline void MSG_PLAYER_SCORE::set_playerscore(const void* value, size_t size) {
  set_has_playerscore();
  if (playerscore_ == &::google::protobuf::internal::kEmptyString) {
    playerscore_ = new ::std::string;
  }
  playerscore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_PLAYER_SCORE::mutable_playerscore() {
  set_has_playerscore();
  if (playerscore_ == &::google::protobuf::internal::kEmptyString) {
    playerscore_ = new ::std::string;
  }
  return playerscore_;
}
inline ::std::string* MSG_PLAYER_SCORE::release_playerscore() {
  clear_has_playerscore();
  if (playerscore_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerscore_;
    playerscore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MSG_PLAYER_WEAPON_CHANGE

// required bytes WeaponChange = 1;
inline bool MSG_PLAYER_WEAPON_CHANGE::has_weaponchange() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_PLAYER_WEAPON_CHANGE::set_has_weaponchange() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_PLAYER_WEAPON_CHANGE::clear_has_weaponchange() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_PLAYER_WEAPON_CHANGE::clear_weaponchange() {
  if (weaponchange_ != &::google::protobuf::internal::kEmptyString) {
    weaponchange_->clear();
  }
  clear_has_weaponchange();
}
inline const ::std::string& MSG_PLAYER_WEAPON_CHANGE::weaponchange() const {
  return *weaponchange_;
}
inline void MSG_PLAYER_WEAPON_CHANGE::set_weaponchange(const ::std::string& value) {
  set_has_weaponchange();
  if (weaponchange_ == &::google::protobuf::internal::kEmptyString) {
    weaponchange_ = new ::std::string;
  }
  weaponchange_->assign(value);
}
inline void MSG_PLAYER_WEAPON_CHANGE::set_weaponchange(const char* value) {
  set_has_weaponchange();
  if (weaponchange_ == &::google::protobuf::internal::kEmptyString) {
    weaponchange_ = new ::std::string;
  }
  weaponchange_->assign(value);
}
inline void MSG_PLAYER_WEAPON_CHANGE::set_weaponchange(const void* value, size_t size) {
  set_has_weaponchange();
  if (weaponchange_ == &::google::protobuf::internal::kEmptyString) {
    weaponchange_ = new ::std::string;
  }
  weaponchange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_PLAYER_WEAPON_CHANGE::mutable_weaponchange() {
  set_has_weaponchange();
  if (weaponchange_ == &::google::protobuf::internal::kEmptyString) {
    weaponchange_ = new ::std::string;
  }
  return weaponchange_;
}
inline ::std::string* MSG_PLAYER_WEAPON_CHANGE::release_weaponchange() {
  clear_has_weaponchange();
  if (weaponchange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weaponchange_;
    weaponchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MSG_PLAYER_WEAPON_CHANGING

// required bytes WeaponChanging = 1;
inline bool MSG_PLAYER_WEAPON_CHANGING::has_weaponchanging() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_PLAYER_WEAPON_CHANGING::set_has_weaponchanging() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_PLAYER_WEAPON_CHANGING::clear_has_weaponchanging() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_PLAYER_WEAPON_CHANGING::clear_weaponchanging() {
  if (weaponchanging_ != &::google::protobuf::internal::kEmptyString) {
    weaponchanging_->clear();
  }
  clear_has_weaponchanging();
}
inline const ::std::string& MSG_PLAYER_WEAPON_CHANGING::weaponchanging() const {
  return *weaponchanging_;
}
inline void MSG_PLAYER_WEAPON_CHANGING::set_weaponchanging(const ::std::string& value) {
  set_has_weaponchanging();
  if (weaponchanging_ == &::google::protobuf::internal::kEmptyString) {
    weaponchanging_ = new ::std::string;
  }
  weaponchanging_->assign(value);
}
inline void MSG_PLAYER_WEAPON_CHANGING::set_weaponchanging(const char* value) {
  set_has_weaponchanging();
  if (weaponchanging_ == &::google::protobuf::internal::kEmptyString) {
    weaponchanging_ = new ::std::string;
  }
  weaponchanging_->assign(value);
}
inline void MSG_PLAYER_WEAPON_CHANGING::set_weaponchanging(const void* value, size_t size) {
  set_has_weaponchanging();
  if (weaponchanging_ == &::google::protobuf::internal::kEmptyString) {
    weaponchanging_ = new ::std::string;
  }
  weaponchanging_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_PLAYER_WEAPON_CHANGING::mutable_weaponchanging() {
  set_has_weaponchanging();
  if (weaponchanging_ == &::google::protobuf::internal::kEmptyString) {
    weaponchanging_ = new ::std::string;
  }
  return weaponchanging_;
}
inline ::std::string* MSG_PLAYER_WEAPON_CHANGING::release_weaponchanging() {
  clear_has_weaponchanging();
  if (weaponchanging_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weaponchanging_;
    weaponchanging_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MSG_SPAWN_PLAYER

// required bytes SpawnPlayer = 1;
inline bool MSG_SPAWN_PLAYER::has_spawnplayer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_SPAWN_PLAYER::set_has_spawnplayer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_SPAWN_PLAYER::clear_has_spawnplayer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_SPAWN_PLAYER::clear_spawnplayer() {
  if (spawnplayer_ != &::google::protobuf::internal::kEmptyString) {
    spawnplayer_->clear();
  }
  clear_has_spawnplayer();
}
inline const ::std::string& MSG_SPAWN_PLAYER::spawnplayer() const {
  return *spawnplayer_;
}
inline void MSG_SPAWN_PLAYER::set_spawnplayer(const ::std::string& value) {
  set_has_spawnplayer();
  if (spawnplayer_ == &::google::protobuf::internal::kEmptyString) {
    spawnplayer_ = new ::std::string;
  }
  spawnplayer_->assign(value);
}
inline void MSG_SPAWN_PLAYER::set_spawnplayer(const char* value) {
  set_has_spawnplayer();
  if (spawnplayer_ == &::google::protobuf::internal::kEmptyString) {
    spawnplayer_ = new ::std::string;
  }
  spawnplayer_->assign(value);
}
inline void MSG_SPAWN_PLAYER::set_spawnplayer(const void* value, size_t size) {
  set_has_spawnplayer();
  if (spawnplayer_ == &::google::protobuf::internal::kEmptyString) {
    spawnplayer_ = new ::std::string;
  }
  spawnplayer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MSG_SPAWN_PLAYER::mutable_spawnplayer() {
  set_has_spawnplayer();
  if (spawnplayer_ == &::google::protobuf::internal::kEmptyString) {
    spawnplayer_ = new ::std::string;
  }
  return spawnplayer_;
}
inline ::std::string* MSG_SPAWN_PLAYER::release_spawnplayer() {
  clear_has_spawnplayer();
  if (spawnplayer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spawnplayer_;
    spawnplayer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PLAYER_IP

// required bytes playerip = 1;
inline bool PLAYER_IP::has_playerip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PLAYER_IP::set_has_playerip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PLAYER_IP::clear_has_playerip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PLAYER_IP::clear_playerip() {
  if (playerip_ != &::google::protobuf::internal::kEmptyString) {
    playerip_->clear();
  }
  clear_has_playerip();
}
inline const ::std::string& PLAYER_IP::playerip() const {
  return *playerip_;
}
inline void PLAYER_IP::set_playerip(const ::std::string& value) {
  set_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    playerip_ = new ::std::string;
  }
  playerip_->assign(value);
}
inline void PLAYER_IP::set_playerip(const char* value) {
  set_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    playerip_ = new ::std::string;
  }
  playerip_->assign(value);
}
inline void PLAYER_IP::set_playerip(const void* value, size_t size) {
  set_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    playerip_ = new ::std::string;
  }
  playerip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PLAYER_IP::mutable_playerip() {
  set_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    playerip_ = new ::std::string;
  }
  return playerip_;
}
inline ::std::string* PLAYER_IP::release_playerip() {
  clear_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerip_;
    playerip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ADD_PEER

// required bytes addpeer = 1;
inline bool ADD_PEER::has_addpeer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ADD_PEER::set_has_addpeer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ADD_PEER::clear_has_addpeer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ADD_PEER::clear_addpeer() {
  if (addpeer_ != &::google::protobuf::internal::kEmptyString) {
    addpeer_->clear();
  }
  clear_has_addpeer();
}
inline const ::std::string& ADD_PEER::addpeer() const {
  return *addpeer_;
}
inline void ADD_PEER::set_addpeer(const ::std::string& value) {
  set_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    addpeer_ = new ::std::string;
  }
  addpeer_->assign(value);
}
inline void ADD_PEER::set_addpeer(const char* value) {
  set_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    addpeer_ = new ::std::string;
  }
  addpeer_->assign(value);
}
inline void ADD_PEER::set_addpeer(const void* value, size_t size) {
  set_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    addpeer_ = new ::std::string;
  }
  addpeer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ADD_PEER::mutable_addpeer() {
  set_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    addpeer_ = new ::std::string;
  }
  return addpeer_;
}
inline ::std::string* ADD_PEER::release_addpeer() {
  clear_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addpeer_;
    addpeer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DELETE_PEER

// required int32 serial = 1;
inline bool DELETE_PEER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DELETE_PEER::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DELETE_PEER::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DELETE_PEER::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 DELETE_PEER::serial() const {
  return serial_;
}
inline void DELETE_PEER::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SFPacketStore

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< SFPacketStore::TeamType>() {
  return SFPacketStore::TeamType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SFPacketStore_2eproto__INCLUDED
